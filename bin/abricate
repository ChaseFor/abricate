#!/usr/bin/env perl

use warnings;
use strict;
use File::Temp qw(tempdir);
use File::Spec;
use Data::Dumper;
use Bio::SeqIO;
use Bio::SearchIO;
use FindBin;

#..............................................................................
# Command line options

my(@Options, $verbose, $datadir, $list, $db, $noheader, $csv, $nopath, $cutoff);
setOptions();

#..............................................................................
# Globals

my $OUTSEP = "\t";

my @BLAST_FIELDS = qw(
  qseqid qstart qend qlen
  sseqid sstart send slen sstrand
  evalue length pident gaps
);

my @COLUMNS = qw(
 FILE SEQUENCE START END GENE COVERAGE COVERAGE_MAP GAPS %COVERAGE %IDENTITY
);
$COLUMNS[0] = '#'.$COLUMNS[0];

#..............................................................................
# Option parsing

if ($list) {
  my $total=0;
  for my $fname (<$datadir/*.fsa>) {
    my $num=0;
    open FASTA, $fname;
    while (<FASTA>) {
      $num++ if m/>/;
    }
    my(undef,undef,$file) = File::Spec->splitpath($fname);
    $file =~ s/.fsa$//;
    print STDERR "$file\t$num\n";
    $total+=$num;
  }
  print STDERR "TOTAL\t$total\n";
  exit;
}

$OUTSEP = ',' if $csv;  # default is tab

# check if 'blastn' installed
my($blast)=qx(which blastn);
$blast && $blast =~ m/blastn/ or die "Could not find 'blastn'. Please install it.";

# output format
my $format = "6 @BLAST_FIELDS";
print line(@COLUMNS) unless $noheader;

for my $fasta (@ARGV) {
  my %seen;
  my @hit;
  print STDERR "Processing: $fasta\n";
  my $cmd = "blastn -query \Q$fasta\E -db $datadir/resfinder "
          . " -task blastn -evalue 1E-99 -dust no -outfmt '$format'"
          . " -culling_limit 1"
#          . " -best_hit_overhang 0.49 -best_hit_score_edge 0.0001"
          ;
  print STDERR "Running: $cmd\n" if $verbose;
  
  open BLAST, "$cmd |";
  while (<BLAST>) { 
#    print "#$_";
    chomp;
    my @x = split m/\t/;
    my %hit = (map { $BLAST_FIELDS[$_] => $x[$_] } 0 .. @BLAST_FIELDS-1); 
    ($hit{sstart}, $hit{send}) = ($hit{send}, $hit{sstart}) if $hit{sstrand} eq 'minus';
    next if $seen{ join('~', @hit{qw(qseqid qstart qend)}) }++;
    $hit{sseqid} =~ s/_.*$//;
#    print STDERR Dumper(\%hit);
    my $minimap = minimap( @hit{qw(sstart send slen gaps)} );
#    $minimap .= '!-'.$hit{gaps} if $hit{gaps} > 0;
    push @hit, [ 
      $fasta, 
      $hit{qseqid}, $hit{qstart}, $hit{qend},
      $hit{sseqid}, 
      $hit{sstart}.'-'.$hit{send}.'/'.$hit{slen}, 
      $minimap, 
      $hit{gaps},
      sprintf("%.2f", 100 * ($hit{length}-$hit{gaps}) / $hit{slen}),
      $hit{pident},
    ];
  }
  close BLAST;

  printf STDERR "Found %d ABR genes in $fasta\n", scalar(@hit);
  @hit = sort { $a->[1] cmp $b->[1] || $a->[2] <=> $b->[2] } @hit;
  print line(@$_) for @hit;
  
}



#----------------------------------------------------------------------

sub minimap {
  my($x, $y, $L, $broken, $scale, $on, $off) = @_;
  my $WIDTH = 15 - ($broken ? 1 : 0);
  $broken ||= 0;
  $scale ||= ($L/$WIDTH);
  $on  ||= '=';
  $off ||= '.';
  $x = int( $x / $scale );
  $y = int( $y / $scale );
  $L = int( $L / $scale );
  my $map='';
  for my $i (0 .. $WIDTH-1) {
#    print STDERR "$i $x $y $L $scale\n";
    $map .= ($i >= $x and $i <= $y) ? $on : $off;
    $map .= '/' if $broken and $i==int($WIDTH/2);
  }
  return $map;
}

#----------------------------------------------------------------------

sub line {
  return join($OUTSEP, @_)."\n";
}

#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"verbose!",  VAR=>\$verbose, DEFAULT=>0, DESC=>"Verbose output"},
    {OPT=>"datadir=s",  VAR=>\$datadir, DEFAULT=>"$FindBin::RealBin/../db", DESC=>"Downloaded ResFinder data"},
    {OPT=>"list!",  VAR=>\$list, DEFAULT=>0, DESC=>"List included ABR databases"},
    {OPT=>"noheader!",  VAR=>\$noheader, DEFAULT=>0, DESC=>"Suppress column header row"},
    {OPT=>"csv!",  VAR=>\$csv, DEFAULT=>0, DESC=>"Output CSV instead of TSV"},
#    {OPT=>"cutoff=f",  VAR=>\$cutoff, DEFAULT=>80, DESC=>"Minimum DNA identity cutoff"},
#    {OPT=>"nopath!",  VAR=>\$nopath, DEFAULT=>0, DESC=>"Strip filename paths from FILE column"},
  );

  @ARGV or usage();

  &GetOptions(map {$_->{OPT}, $_->{VAR}} @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

sub usage {
  print "Usage: $0 [options] <contigs.fasta> ... \n";
  foreach (@Options) {
    printf "  --%-13s %s%s.\n",$_->{OPT},$_->{DESC},
           defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
  }
  exit(1);
}
 
#----------------------------------------------------------------------
