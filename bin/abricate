#!/usr/bin/env perl

use warnings;
use strict;
use File::Spec;
use Data::Dumper;
use FindBin;

#..............................................................................
# Command line options

my $VERSION = "0.3";

my(@Options, $debug, $datadir, $list, $db, $noheader, $csv, $nopath, $minid, $cull);
setOptions();

#..............................................................................
# Globals

my $OUTSEP = "\t";

my @BLAST_FIELDS = qw(
  qseqid qstart qend qlen
  sseqid sstart send slen sstrand
  evalue length pident gaps
);

my @COLUMNS = qw(
 FILE SEQUENCE START END GENE COVERAGE COVERAGE_MAP GAPS %COVERAGE %IDENTITY
);
$COLUMNS[0] = '#'.$COLUMNS[0];

#..............................................................................
# Option parsing

if ($list) {
  my $total=0;
  for my $fname (<$datadir/*.fsa>) {
    my $num=0;
    open FASTA, $fname;
    while (<FASTA>) {
      $num++ if m/>/;
    }
    my(undef,undef,$file) = File::Spec->splitpath($fname);
    $file =~ s/.fsa$//;
    print STDERR "$file\t$num\n";
    $total+=$num;
  }
  print STDERR "TOTAL\t$total\n";
  exit;
}

$OUTSEP = ',' if $csv;  # default is tab

# check if 'blastn' installed
my($blast)=qx(which blastn);
$blast && $blast =~ m/blastn/ or die "Could not find 'blastn'. Please install it.";

# check if blastn > 2.2.30 to support 'gaps' custom field
my($version) = qx(blastn -version 2>&1);
$version =~ m/2.(\d+.\d+)\+/ or die "Could not parse blastn version from '$version'";
$1 >= 2.30 or die "You need to install BLAST+ 2.2.30 or higher";

# output format
my $format = "6 @BLAST_FIELDS";
print line(@COLUMNS) unless $noheader;

for my $fasta (@ARGV) {
  my %seen;
  my @hit;
  print STDERR "Processing: $fasta\n";
  my $cmd = "blastn -query \Q$fasta\E -db \Q$datadir/resfinder\E -outfmt '$format'"
          . " -task blastn -evalue 1E-20 -dust no -max_target_seqs 10000 -perc_identity $minid"
          . " -culling_limit $cull"
          ;
  print STDERR "Running: $cmd\n" if $debug;
  
  open BLAST, "$cmd |";
  while (<BLAST>) { 
#    print "#$_";
    chomp;
    my @x = split m/\t/;
    my %hit = (map { $BLAST_FIELDS[$_] => $x[$_] } 0 .. @BLAST_FIELDS-1); 
    ($hit{sstart}, $hit{send}) = ($hit{send}, $hit{sstart}) if $hit{sstrand} eq 'minus';
    next if $seen{ join('~', @hit{qw(qseqid qstart qend)}) }++;
    $hit{sseqid} =~ s/_.*$//;
#    print STDERR Dumper(\%hit);
    my $minimap = minimap( @hit{qw(sstart send slen gaps)} );
#    $minimap .= '!-'.$hit{gaps} if $hit{gaps} > 0;
    push @hit, [ 
      $fasta, 
      $hit{qseqid}, $hit{qstart}, $hit{qend},
      $hit{sseqid}, 
      $hit{sstart}.'-'.$hit{send}.'/'.$hit{slen}, 
      $minimap, 
      $hit{gaps},
      sprintf("%.2f", 100 * ($hit{length}-$hit{gaps}) / $hit{slen}),
      $hit{pident},
    ];
  }
  close BLAST;

  printf STDERR "Found %d ABR genes in $fasta\n", scalar(@hit);
  @hit = sort { $a->[4] cmp $b->[4] || $b->[8] <=> $a->[8] } @hit;
#  @hit = sort { $a->[1] cmp $b->[1] || $b->[2] <=> $a->[2] } @hit;

  # filter hits after we sort based on what we want
  # keep the first one we find of the same gene on the same contig
  # this is NOT perfect and could remove duplicates on same contig!!!!
  # need to take overlap into consideration
  my @filt;
  my %have;
#  foreach (@hit) {
#    push @filt, $_ unless $have{ $_->[1].$_->[4] }++;
#  }
  @filt = @hit;
  printf STDERR "Filtered %d hits, %d remain.\n", scalar(@hit), scalar(@filt);

  print line(@$_) for @filt;  
}

#----------------------------------------------------------------------

sub minimap {
  my($x, $y, $L, $broken, $scale, $on, $off) = @_;
  my $WIDTH = 15 - ($broken ? 1 : 0);
  $broken ||= 0;
  $scale ||= ($L/$WIDTH);
  $on  ||= '=';
  $off ||= '.';
  $x = int( $x / $scale );
  $y = int( $y / $scale );
  $L = int( $L / $scale );
  my $map='';
  for my $i (0 .. $WIDTH-1) {
#    print STDERR "$i $x $y $L $scale\n";
    $map .= ($i >= $x and $i <= $y) ? $on : $off;
    $map .= '/' if $broken and $i==int($WIDTH/2);
  }
  return $map;
}

#----------------------------------------------------------------------

sub line {
  return join($OUTSEP, @_)."\n";
}

#----------------------------------------------------------------------

sub version {
  print "$FindBin::RealScript $VERSION\n";
  exit;
}

#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"debug!",  VAR=>\$debug, DEFAULT=>0, DESC=>"Verbose debug output"},
    {OPT=>"version!",  VAR=>\&version, DESC=>"Print version and exit"},
    {OPT=>"datadir=s",  VAR=>\$datadir, DEFAULT=>"$FindBin::RealBin/../db", DESC=>"Downloaded ResFinder data"},
    {OPT=>"list!",  VAR=>\$list, DEFAULT=>0, DESC=>"List included ABR databases"},
    {OPT=>"noheader!",  VAR=>\$noheader, DEFAULT=>0, DESC=>"Suppress column header row"},
    {OPT=>"csv!",  VAR=>\$csv, DEFAULT=>0, DESC=>"Output CSV instead of TSV"},
    {OPT=>"minid=f",  VAR=>\$minid, DEFAULT=>75, DESC=>"Minimum DNA identity"},
    {OPT=>"cull=i",  VAR=>\$cull, DEFAULT=>1, DESC=>"Culling limit (encompassing hits)"},
#    {OPT=>"nopath!",  VAR=>\$nopath, DEFAULT=>0, DESC=>"Strip filename paths from FILE column"},
  );

  @ARGV or usage();

  &GetOptions(map {$_->{OPT}, $_->{VAR}} @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

sub usage {
  print "Usage: $0 [options] <contigs.fasta> ... \n";
  foreach (@Options) {
    printf "  --%-13s %s%s.\n",$_->{OPT},$_->{DESC},
           defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
  }
  exit(1);
}
 
#----------------------------------------------------------------------
