#!/usr/bin/env perl
use strict;
use Bio::SeqIO;
use File::Spec;
use File::Temp qw(tempdir);
use Data::Dumper;

#..............................................................................
# Databases

my %DB = (
  'Resfinder' => {
    URL => 'https://cge.cbs.dtu.dk/cge/download_data.php?folder=resfinder&filename=resfinder.zip&submit=resfinder.zip',
    EXT => 'zip',
    GLB => '*.fsa',
    PAT => qr/^(.*)_/,
    PRI => 1,
  },
  'NCBI-betalactamases' => {
    URL => 'ftp://ftp.ncbi.nlm.nih.gov/pathogen/betalactamases/Allele-dna.fa'
    EXT => '',
    GLB => '*.fa',
    PAT => qr/>(.*?)\s?/,
    PRI => 2,
  }
  'ARG-ANNOT' => {
    URL => 'http://www.mediterranee-infection.com/arkotheque/client/ihumed/_depot_arko/articles/691/argannot-nt_doc.fasta'
    EXT => '',
    GLB => '*.fasta',
    PAT => qr/^(.*?):/,
    PRI => 3,
  },
#  'ARG-ANNOT' => {
#    URL => 'http://www.mediterranee-infection.com/arkotheque/client/ihumed/_depot_arko/articles/304/arg-annot-database_doc.zip',
#    EXT => 'zip',
#    GLB => '*Nt Sequences*.txt',
#    PAT => qr/^(.*?):/,
#    PRI => 3,
#  },
  'CARD' => {
    URL => 'https://card.mcmaster.ca/download/0/broadsteet-v1.0.5.tar.gz',
    EXT => 'tar.bz2',  # website says .gz but it is .bz2 !!! 
    GLB => 'nucleotide_fasta*homolog*.fasta',
    PAT => qr/\|(.*?)$/,
    PRI => 4,
  }
);

my @SEQ;
my %seen;

#..............................................................................
# Command line options

my(@Options, $debug, $force);
setOptions();

my $dir = tempdir(CLEANUP=>1);
print STDERR "Using temp dir: $dir\n";

#..............................................................................
# Process each database in PRI order

for my $db (sort { $DB{$a}{PRI} <=> $DB{$b}{PRI} } keys %DB) {
  
  # Download
  my $file = join('.', $db, $DB{$db}{EXT});
  if ($force or ! -r $file) {
    print STDERR "Downloading $file\n";
    system("wget -N -O $file \Q$DB{$db}{URL}\E");
  }
  else {
    print STDERR "Re-using existing $file\n";
  }
  
  # Make folder to extract to
  my $exdir = "$dir/$db";
  print STDERR "Making folder: $exdir\n";
  mkdir $exdir;
  
  # Extract without paths
  print STDERR "Extracting $file\n";
  if ($file =~ m/zip$/) {
    system("unzip -q -j -d $exdir $file");
  }
  elsif ($file =~ m/\.tar\./) {
    system("tar -C $exdir -xf $file");
  }
  else {
    system("mkdir $exdir && cp '$file' $exdir/");
#    die "Unknown file archive: $file";
  }
  
  # Find the sequence file(s)
  my @fasta = glob( qq("$exdir/$DB{$db}{GLB}") ); # quote for spaces in GLB
  print STDERR "Found $db files: @fasta\n";
  
  # Incorporate into our database
  for my $fasta (@fasta) {
    print STDERR "Adding $db: $fasta\n";
    my $in = Bio::SeqIO->new(-file=>$fasta, -format=>'fasta');
    while (my $seq = $in->next_seq) {
      $seq->id =~ $DB{$db}{PAT};
      $seq = fix_sequence($seq, $db, $1);
      push @SEQ, $seq if $seq;
    }
    printf STDERR "Now have %d unique sequences.\n", scalar(@SEQ);
  }
}

my $out = Bio::SeqIO->new(-fh=>\*STDOUT, -format=>'fasta');
for my $seq (@SEQ) {
  $out->write_seq($seq);
}


sub fix_sequence {
  my($seq, $db, $newid) = @_;

  my $id = $seq->display_id;
  $newid ||= $id; # if undef
  my $ID = "$db:$newid $id";

  if ($seq->length <= 0) {
    print STDERR "$ID - is an empty sequence!\n";
    return;
  }

  if ($seq->length % 3 != 0) {
    print STDERR "$ID - length ".$seq->length." not multiple of 3\n";
  }

  if ($seq->seq =~ m/([^AGCT]+)/i) {
    print STDERR "$ID - contains non-AGTC bases: $1\n";
    return;
  }
  
  my $aa = $seq->translate->seq;
  if ($aa =~ m/\*./) {
    $aa = $seq->revcom->translate->seq;
    if ($aa =~ m/\*./) {
      print STDERR "$ID - fwd & rev have internal stop codons too\n";
#      return;
    }
    else {
      print STDERR "$ID - fwd has internal stop codins but rev is ok\n";
      $seq = $seq->revcom;
    }
  }

  my $key = uc($seq->seq);
  
  if (my $dupe = $seen{$key}) {
    print STDERR "$ID - skipping duplicate DNA sequence: $dupe\n";
    return;
  }
  else {
    $seen{$key} = $id;
  }

  #print STDERR "$id - ok\n";
  $seq->desc("$db:$id");
  $seq->id($newid);
  return $seq;
}


#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"debug!",  VAR=>\$debug, DEFAULT=>0, DESC=>"Verbose debug output"},
    {OPT=>"force!",  VAR=>\$force, DEFAULT=>0, DESC=>"Force download even if exists"},
  );

#  @ARGV or usage();

  &GetOptions(map {$_->{OPT}, $_->{VAR}} @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

sub usage {
  print "Usage: $0 [options]\n";
  foreach (@Options) {
    printf "  --%-13s %s%s.\n",$_->{OPT},$_->{DESC},
           defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
  }
  exit(1);
}
 
#----------------------------------------------------------------------

